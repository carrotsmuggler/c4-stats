#!/usr/bin/env python3

import sys
import subprocess
import csv
import urllib.request
from io import StringIO
import json
import argparse
import dateutil.parser
import datetime

CODE_ARENA="https://raw.githubusercontent.com/code-423n4/code423n4.com/main/_data"

FINDINGS_URL=f"{CODE_ARENA}/findings/findings.csv"
CONTESTS_URL=f"{CODE_ARENA}/contests/contests.csv"

parser = argparse.ArgumentParser(prog="c4-stats")
subp = parser.add_subparsers(dest="command") # dest="command" means that we see which command was parsed

statsp = subp.add_parser("basic", description="Basic statistics",help="stats help")
statsp.add_argument('warden',type=str, nargs='+')

distribp = subp.add_parser("by-contest", description="Show award for each contest in descending order of award")
distribp.add_argument('warden', type=str, nargs='+')

ns = parser.parse_args(sys.argv[1:])

#
# Functions
#
def get_records(url):
  response = urllib.request.urlopen(url)
  csv_data = response.read()
  rs = []
  file = StringIO(bytes.decode(csv_data, "UTF-8"))
  csvr = csv.reader(file)
  headers = next(csvr, None)

  for row in csvr:
    r = {}
    for i in range(0, len(headers)):
      r[headers[i]] = row[i]
    rs.append(r)
  return rs

findings_records = get_records(FINDINGS_URL)
contest_records=get_records(CONTESTS_URL)

def make_contest_hash(rs):
  result = {}
  for r in rs:
    result[r['contestid']] = r
  return result

contest_hash = make_contest_hash(contest_records)

def ppUSD(n):
  return '${:0,.2f}'.format(round(n, 2))

def ppMonth(str):
  dt = dateutil.parser.parse(str)
  return dt.strftime("%B %Y")

def basic_stats():
  stats = { }
  lastContest = 0
  for r in findings_records:
    lastContest = r["contest"]
    if r["handle"]:
      handle = r["handle"]
      if not handle in stats:
        stats[handle] = { "handle": handle, "contests": 0, "highs": 0, "mediums": 0, "qaReports": 0, "gasReports": 0, "submissions": 0, "total": 0, "lastContest": 0 }
      if lastContest != stats[handle]["lastContest"]:
        stats[handle]["contests"] += 1
        stats[handle]["lastContest"] = lastContest
      if r["finding"][0:1] == "H":
        stats[handle]["highs"] += 1
      if r["finding"][0:1] == "M":
        stats[handle]["mediums"] += 1
      if r["finding"][0:1] == "Q":
        stats[handle]["qaReports"] += 1
      if r["finding"][0:1] == "G":
        stats[handle]["gasReports"] += 1
      stats[handle]["submissions"] += 1
      stats[handle]["total"] += float(r["awardUSD"])

  for h in stats.keys():
    del stats[h]["lastContest"]
    stats[h]["averagePerContest"] = ppUSD(stats[h]["total"] / stats[h]["contests"])
    stats[h]["averagePerSubmission"] = ppUSD(stats[h]["total"] / stats[h]["submissions"])
    stats[h]["total"] = ppUSD(stats[h]["total"])


  # Collate results
  results = []
  for warden in ns.warden:
    if warden in stats:
      results.append(stats[warden])
    else:
      results.append({ "error" : f"Warden '{warden}' has not competed" })
  return results


def byContest(wardens):
  results = []
  for warden in wardens:
    stats = []
    h = {}
    for r in findings_records:
      if r['handle'] and r['handle'] == warden:
        award = float(r['awardUSD'])
        if not r['contest'] in h:
          c = contest_hash[r['contest']]
          h[r['contest']] = { 'contest' : c['title'], 'amount': c['amount'], 'date': ppMonth(c['start_time']), 'awardUSD' : 0.0 }
        h[r['contest']]['awardUSD'] += award
    for k in h:
      stats.append(h[k])
    stats.sort(key=lambda r: -float(r['awardUSD']))
    for s in stats:
      s['awardUSD'] = ppUSD(s['awardUSD'])
    results.append({ 'warden': warden, 'distribution': stats} if len(stats) > 0 else { 'error': f'Warden {warden} does not exist'})
  return results


## Prints the records as valid JSON

if ns.command == "basic":
  result = basic_stats()
elif ns.command == "by-contest":
  result = byContest(ns.warden)


print(json.dumps(result, indent=2))

